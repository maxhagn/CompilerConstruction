%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "grammar_tree.h"
#include "code_generator.h"
%}

%start program
%term OP_RETURN=0 OP_ADDRESS_READ=1 OP_ADD=2 OP_MUL=3 OP_AND=4 OP_GREATER=5 OP_EQUAL=6 OP_NOT=7 OP_SUB=8 OP_NUMBER=9 OP_ID=10

%%

program: def                            # 0 #

def:    stats                           # 0 #

stats:  stat                            # 0 #

stat:   ret                             # 1 #

ret:    OP_RETURN(expr)                 # 1 #   assembleReturnWithValue(bnode->reg);

expr:   const                           # 1 #   assembleMovev(bnode->value, bnode->reg);

expr:   OP_ADDRESS_READ(expr)           # 1 #   assembleAddressRead(bnode->kids[0]->reg, bnode->reg);

expr:   OP_ADD(expr, expr)              # 1 #   assembleAdd(bnode->kids[1]->reg, bnode->kids[0]->reg);
expr:   OP_ADD(const, expr)             # 1 #   assembleAddv(bnode->kids[0]->value, bnode->kids[1]->reg); assembleMove(bnode->kids[1]->reg, bnode->reg);
expr:   OP_ADD(expr, const)             # 1 #   assembleAddv(bnode->kids[1]->value, bnode->kids[0]->reg);

expr:   OP_MUL(expr, expr)              # 1 #   assembleMul(bnode->kids[1]->reg, bnode->kids[0]->reg);
expr:   OP_MUL(const, expr)             # 1 #   assembleMulv(bnode->kids[0]->value, bnode->kids[1]->reg); assembleMove(bnode->kids[1]->reg, bnode->reg);
expr:   OP_MUL(expr, const)             # 1 #   assembleMulv(bnode->kids[1]->value, bnode->kids[0]->reg);

expr:   OP_AND(expr, expr)              # 1 #   assembleAnd(bnode->kids[1]->reg, bnode->kids[0]->reg);
expr:   OP_AND(const, expr)             # 1 #   assembleAndv(bnode->kids[0]->value, bnode->kids[1]->reg); assembleMove(bnode->kids[1]->reg, bnode->reg);
expr:   OP_AND(expr, const)             # 1 #   assembleAndv(bnode->kids[1]->value, bnode->kids[0]->reg);

expr:   OP_GREATER(expr, expr)          # 1 #   assembleGreater(bnode->kids[1]->reg, bnode->kids[0]->reg, bnode->reg);
expr:   OP_GREATER(expr, const)         # 1 #   assembleGreaterFv(bnode->kids[1]->value, bnode->kids[0]->reg, bnode->reg);

expr:   OP_EQUAL(expr, expr)            # 1 #   assembleEqual(bnode->kids[1]->reg, bnode->kids[0]->reg, bnode->reg);
expr:   OP_EQUAL(const, expr)           # 1 #   assembleEqualv(bnode->kids[0]->value, bnode->kids[1]->reg, bnode->reg);
expr:   OP_EQUAL(expr, const)           # 1 #   assembleEqualv(bnode->kids[1]->value, bnode->kids[0]->reg, bnode->reg);

expr:   OP_NOT(expr)                    # 1 #   assembleNot(bnode->reg);
expr:   OP_SUB(expr)                    # 1 #   assembleNeg(bnode->reg);
expr:   OP_ID                           # 1 #   if (bnode->index != -1) assembleMoveWithOffset(getParameterRegister(bnode->index, bnode->offset), bnode->reg);

const:  OP_NUMBER                       # 0 #
const:  OP_ADD(const, const)            # 0 #   bnode->value = bnode->kids[0]->value + bnode->kids[1]->value;
const:  OP_MUL(const, const)            # 0 #   bnode->value = bnode->kids[0]->value * bnode->kids[1]->value;
const:  OP_AND(const, const)            # 0 #   bnode->value = bnode->kids[0]->value & bnode->kids[1]->value;
const:  OP_GREATER(const, const)        # 0 #   bnode->value = bnode->kids[0]->value >  bnode->kids[1]->value ? 1 : 0;
const:  OP_EQUAL(const, const)          # 0 #   bnode->value = bnode->kids[0]->value == bnode->kids[1]->value ? 1 : 0;
const:  OP_NOT(const)                   # 0 #   bnode->value = ~bnode->kids[0]->value;
const:  OP_SUB(const)                   # 0 #   bnode->value = -bnode->kids[0]->value;

%%

extern TreeNode *root;
void burm_reduce(NODEPTR_TYPE bnode, int goalnt);

void invoke_burm(NODEPTR_TYPE root) {
    burm_label(root);
    burm_reduce(root, 1);
}

